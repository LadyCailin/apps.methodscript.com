# Swagger generated server

## Overview
The binding code for this server was generated by the [swagger-codegen](https://github.com/swagger-api/swagger-codegen) project.

### Running the server
In production, to run the server, use

```
npm start
```

To view the Swagger UI interface:

```
open http://url:8080/docs
```

On your local machine, to run the server, you probably want to instead start the server with

```
npm run-script local-start
```

Which configures a few settings, such as a more open CORS policy, as well as starts the server up listening for debug connections.

### Debugging

To debug the server, start the server using `npm run-script local-start` as above. Then, in your browser, open `chrome://inspect` for Chrome,
and `edge://inspect` for Edge. Click on the `Open dedicated DevTools for Node` link. In the connection tab, ensure that it is configured to
connect to `localhost:9229`. If so, it should automatically connect.

Once connected, in the Sources tab, you should then see the files for the server, and can set breakpoints as usual.

If you want the server to hit a breakpoint at the start, so you can observe startup, you can instead use `npm run-script local-start-break`.

## Development

It is extremely important to understand what code is automatically generated, and what is manually generated. Most of the glue code is
subject to being overwritten when the update-apps-api.cmd script is run, so it's important to put your changes in the appropriate location.

All files in the controllers and service folders are automatically generated - do not make any manual changes here. Initially, the index.js,
package.json, and README were automatically generated, but they are no longer re-generated, feel free to make changes here. The api/openapi.yaml
file is regenerated. The utils/writer.js file is automatically generated, but the template is 1:1, so if you
need to change that file, simply make the changes in mustacheTemplates/writer.mustache instead.

In general, the template files can be found in mustacheTemplates. The controller.mustache, service.mustache, and writer.mustache are the most interesting
files, the remaining ones simply need to be there for the system to process the templates.

If you need to add or modify paths, you must make the changes in the openapi spec in the main project, and then run the `update-apps-api.cmd` script.
If you have added new paths for instance, this will add the wiring code in both the Java and this project, and ensure they remain in sync at all times.
The business logic resides in the src/api/ folder, and all files in src/ are not automatically generated.

The files in src/ are meant to be TypeScript files, and while the glue code is JavaScript, this fact should generally be ignored, and new code
written in TypeScript. API endpoints should return either string or ResponseObject.

Keep in mind, however, that while the bleeding edge server and client will always match, the server must continue to support older clients,
and so can only deprecate capabilities within the deprecation guidelines.

## Connecting locally
When developing, you probably will be running the server locally, using the MethodScript client. In this case, you'll want to start up MethodScript
directly, and provide the java command with `-Dmethodscript.apps.server="http://localhost:8080"` which will configure the client to hit that url
instead of `apps.methodscript.com` directly.

### Deprecation guidelines
There is support built in for deprecating server features. Some features are not user visible, and so may be removed without notice period, but
for user visible features, the general timeline is a minimum year of deprecation, and longer for features that are difficult to replace. Where
justification exists, shorter periods can be specified.

There are two types of deprecations, feature removal, and feature changes. Further, the actions are different depending on whether or not
there is a replacement feature in newer versions.

For feature removals where a new version contains the replacement functionality, the feature should be set to `update DATE`
in the `GET /` call. This will trigger the client to begin warning the user that they need to update the client before DATE.
Ensure that the replacement functionality has already been fully rolled out in both the server and the new client builds
before doing this. After the specified date, the feature can then be removed.

For feature removals where the feature is simply deprecated, and is no longer useful, there are two possibilities. In general,
before using a feature, the client always checks if a feature is supported. If a feature is removed from this list, then the
client will not try to use the functionality in the first place. If the feature is set to `deprecated DATE`, then it will continue
to use the service, but will notify the user that the feature is being deprecated, and will be removed at the specified date.

### Setting up secrets
Secrets are not stored in the source code, but are required for many operations. These secrets should simply be exported to the
environment, and will be read in appropriately during runtime. To make development work easier, all places that use secrets
should have some fallback if secrets are missing (even if they just gracefully disable themselves) rather than crashing the
program. _Incorrect_ secrets however, may cause a crash.

For reference, to set an environmental variable in bash, use `export SecretName=Secret` and in batch, use `set SecretName=Secret`.
These values can be read in code with `process.env.SecretName`, and may be undefined.